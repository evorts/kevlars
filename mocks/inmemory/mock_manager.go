// Code generated by mockery v2.42.3. DO NOT EDIT.

package inmemory

import (
	context "context"

	inmemory "github.com/evorts/kevlars/inmemory"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// Manager is an autogenerated mock type for the Manager type
type Manager struct {
	mock.Mock
}

type Manager_Expecter struct {
	mock *mock.Mock
}

func (_m *Manager) EXPECT() *Manager_Expecter {
	return &Manager_Expecter{mock: &_m.Mock}
}

// Connect provides a mock function with given fields: ctx
func (_m *Manager) Connect(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type Manager_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Manager_Expecter) Connect(ctx interface{}) *Manager_Connect_Call {
	return &Manager_Connect_Call{Call: _e.mock.On("Connect", ctx)}
}

func (_c *Manager_Connect_Call) Run(run func(ctx context.Context)) *Manager_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Manager_Connect_Call) Return(_a0 error) *Manager_Connect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_Connect_Call) RunAndReturn(run func(context.Context) error) *Manager_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// Del provides a mock function with given fields: ctx, keys
func (_m *Manager) Del(ctx context.Context, keys ...string) error {
	_va := make([]interface{}, len(keys))
	for _i := range keys {
		_va[_i] = keys[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Del")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ...string) error); ok {
		r0 = rf(ctx, keys...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_Del_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Del'
type Manager_Del_Call struct {
	*mock.Call
}

// Del is a helper method to define mock.On call
//   - ctx context.Context
//   - keys ...string
func (_e *Manager_Expecter) Del(ctx interface{}, keys ...interface{}) *Manager_Del_Call {
	return &Manager_Del_Call{Call: _e.mock.On("Del",
		append([]interface{}{ctx}, keys...)...)}
}

func (_c *Manager_Del_Call) Run(run func(ctx context.Context, keys ...string)) *Manager_Del_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *Manager_Del_Call) Return(_a0 error) *Manager_Del_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_Del_Call) RunAndReturn(run func(context.Context, ...string) error) *Manager_Del_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, key, bindTo
func (_m *Manager) Get(ctx context.Context, key string, bindTo interface{}) error {
	ret := _m.Called(ctx, key, bindTo)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, bindTo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type Manager_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bindTo interface{}
func (_e *Manager_Expecter) Get(ctx interface{}, key interface{}, bindTo interface{}) *Manager_Get_Call {
	return &Manager_Get_Call{Call: _e.mock.On("Get", ctx, key, bindTo)}
}

func (_c *Manager_Get_Call) Run(run func(ctx context.Context, key string, bindTo interface{})) *Manager_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *Manager_Get_Call) Return(_a0 error) *Manager_Get_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_Get_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *Manager_Get_Call {
	_c.Call.Return(run)
	return _c
}

// GetString provides a mock function with given fields: ctx, key
func (_m *Manager) GetString(ctx context.Context, key string) string {
	ret := _m.Called(ctx, key)

	if len(ret) == 0 {
		panic("no return value specified for GetString")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Manager_GetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetString'
type Manager_GetString_Call struct {
	*mock.Call
}

// GetString is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
func (_e *Manager_Expecter) GetString(ctx interface{}, key interface{}) *Manager_GetString_Call {
	return &Manager_GetString_Call{Call: _e.mock.On("GetString", ctx, key)}
}

func (_c *Manager_GetString_Call) Run(run func(ctx context.Context, key string)) *Manager_GetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *Manager_GetString_Call) Return(_a0 string) *Manager_GetString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_GetString_Call) RunAndReturn(run func(context.Context, string) string) *Manager_GetString_Call {
	_c.Call.Return(run)
	return _c
}

// HDel provides a mock function with given fields: ctx, key, fields
func (_m *Manager) HDel(ctx context.Context, key string, fields ...string) error {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HDel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...string) error); ok {
		r0 = rf(ctx, key, fields...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_HDel_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HDel'
type Manager_HDel_Call struct {
	*mock.Call
}

// HDel is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - fields ...string
func (_e *Manager_Expecter) HDel(ctx interface{}, key interface{}, fields ...interface{}) *Manager_HDel_Call {
	return &Manager_HDel_Call{Call: _e.mock.On("HDel",
		append([]interface{}{ctx, key}, fields...)...)}
}

func (_c *Manager_HDel_Call) Run(run func(ctx context.Context, key string, fields ...string)) *Manager_HDel_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Manager_HDel_Call) Return(_a0 error) *Manager_HDel_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_HDel_Call) RunAndReturn(run func(context.Context, string, ...string) error) *Manager_HDel_Call {
	_c.Call.Return(run)
	return _c
}

// HGet provides a mock function with given fields: ctx, key, field, bindTo
func (_m *Manager) HGet(ctx context.Context, key string, field string, bindTo interface{}) error {
	ret := _m.Called(ctx, key, field, bindTo)

	if len(ret) == 0 {
		panic("no return value specified for HGet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok {
		r0 = rf(ctx, key, field, bindTo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_HGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGet'
type Manager_HGet_Call struct {
	*mock.Call
}

// HGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - bindTo interface{}
func (_e *Manager_Expecter) HGet(ctx interface{}, key interface{}, field interface{}, bindTo interface{}) *Manager_HGet_Call {
	return &Manager_HGet_Call{Call: _e.mock.On("HGet", ctx, key, field, bindTo)}
}

func (_c *Manager_HGet_Call) Run(run func(ctx context.Context, key string, field string, bindTo interface{})) *Manager_HGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *Manager_HGet_Call) Return(_a0 error) *Manager_HGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_HGet_Call) RunAndReturn(run func(context.Context, string, string, interface{}) error) *Manager_HGet_Call {
	_c.Call.Return(run)
	return _c
}

// HGetAll provides a mock function with given fields: ctx, key, bindTo
func (_m *Manager) HGetAll(ctx context.Context, key string, bindTo interface{}) error {
	ret := _m.Called(ctx, key, bindTo)

	if len(ret) == 0 {
		panic("no return value specified for HGetAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, bindTo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_HGetAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HGetAll'
type Manager_HGetAll_Call struct {
	*mock.Call
}

// HGetAll is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - bindTo interface{}
func (_e *Manager_Expecter) HGetAll(ctx interface{}, key interface{}, bindTo interface{}) *Manager_HGetAll_Call {
	return &Manager_HGetAll_Call{Call: _e.mock.On("HGetAll", ctx, key, bindTo)}
}

func (_c *Manager_HGetAll_Call) Run(run func(ctx context.Context, key string, bindTo interface{})) *Manager_HGetAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *Manager_HGetAll_Call) Return(_a0 error) *Manager_HGetAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_HGetAll_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *Manager_HGetAll_Call {
	_c.Call.Return(run)
	return _c
}

// HMGet provides a mock function with given fields: ctx, key, field, bindTo
func (_m *Manager) HMGet(ctx context.Context, key string, field string, bindTo interface{}) error {
	ret := _m.Called(ctx, key, field, bindTo)

	if len(ret) == 0 {
		panic("no return value specified for HMGet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok {
		r0 = rf(ctx, key, field, bindTo)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_HMGet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMGet'
type Manager_HMGet_Call struct {
	*mock.Call
}

// HMGet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - bindTo interface{}
func (_e *Manager_Expecter) HMGet(ctx interface{}, key interface{}, field interface{}, bindTo interface{}) *Manager_HMGet_Call {
	return &Manager_HMGet_Call{Call: _e.mock.On("HMGet", ctx, key, field, bindTo)}
}

func (_c *Manager_HMGet_Call) Run(run func(ctx context.Context, key string, field string, bindTo interface{})) *Manager_HMGet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *Manager_HMGet_Call) Return(_a0 error) *Manager_HMGet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_HMGet_Call) RunAndReturn(run func(context.Context, string, string, interface{}) error) *Manager_HMGet_Call {
	_c.Call.Return(run)
	return _c
}

// HMSet provides a mock function with given fields: ctx, key, values
func (_m *Manager) HMSet(ctx context.Context, key string, values ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HMSet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) error); ok {
		r0 = rf(ctx, key, values...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_HMSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HMSet'
type Manager_HMSet_Call struct {
	*mock.Call
}

// HMSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - values ...interface{}
func (_e *Manager_Expecter) HMSet(ctx interface{}, key interface{}, values ...interface{}) *Manager_HMSet_Call {
	return &Manager_HMSet_Call{Call: _e.mock.On("HMSet",
		append([]interface{}{ctx, key}, values...)...)}
}

func (_c *Manager_HMSet_Call) Run(run func(ctx context.Context, key string, values ...interface{})) *Manager_HMSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Manager_HMSet_Call) Return(_a0 error) *Manager_HMSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_HMSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) error) *Manager_HMSet_Call {
	_c.Call.Return(run)
	return _c
}

// HSet provides a mock function with given fields: ctx, key, value
func (_m *Manager) HSet(ctx context.Context, key string, value ...interface{}) error {
	var _ca []interface{}
	_ca = append(_ca, ctx, key)
	_ca = append(_ca, value...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HSet")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...interface{}) error); ok {
		r0 = rf(ctx, key, value...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_HSet_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSet'
type Manager_HSet_Call struct {
	*mock.Call
}

// HSet is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value ...interface{}
func (_e *Manager_Expecter) HSet(ctx interface{}, key interface{}, value ...interface{}) *Manager_HSet_Call {
	return &Manager_HSet_Call{Call: _e.mock.On("HSet",
		append([]interface{}{ctx, key}, value...)...)}
}

func (_c *Manager_HSet_Call) Run(run func(ctx context.Context, key string, value ...interface{})) *Manager_HSet_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(context.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *Manager_HSet_Call) Return(_a0 error) *Manager_HSet_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_HSet_Call) RunAndReturn(run func(context.Context, string, ...interface{}) error) *Manager_HSet_Call {
	_c.Call.Return(run)
	return _c
}

// HSetWhenNotExist provides a mock function with given fields: ctx, key, field, value
func (_m *Manager) HSetWhenNotExist(ctx context.Context, key string, field string, value interface{}) error {
	ret := _m.Called(ctx, key, field, value)

	if len(ret) == 0 {
		panic("no return value specified for HSetWhenNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, interface{}) error); ok {
		r0 = rf(ctx, key, field, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_HSetWhenNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HSetWhenNotExist'
type Manager_HSetWhenNotExist_Call struct {
	*mock.Call
}

// HSetWhenNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - field string
//   - value interface{}
func (_e *Manager_Expecter) HSetWhenNotExist(ctx interface{}, key interface{}, field interface{}, value interface{}) *Manager_HSetWhenNotExist_Call {
	return &Manager_HSetWhenNotExist_Call{Call: _e.mock.On("HSetWhenNotExist", ctx, key, field, value)}
}

func (_c *Manager_HSetWhenNotExist_Call) Run(run func(ctx context.Context, key string, field string, value interface{})) *Manager_HSetWhenNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(interface{}))
	})
	return _c
}

func (_c *Manager_HSetWhenNotExist_Call) Return(_a0 error) *Manager_HSetWhenNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_HSetWhenNotExist_Call) RunAndReturn(run func(context.Context, string, string, interface{}) error) *Manager_HSetWhenNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// MustConnect provides a mock function with given fields: ctx
func (_m *Manager) MustConnect(ctx context.Context) inmemory.Manager {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for MustConnect")
	}

	var r0 inmemory.Manager
	if rf, ok := ret.Get(0).(func(context.Context) inmemory.Manager); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(inmemory.Manager)
		}
	}

	return r0
}

// Manager_MustConnect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MustConnect'
type Manager_MustConnect_Call struct {
	*mock.Call
}

// MustConnect is a helper method to define mock.On call
//   - ctx context.Context
func (_e *Manager_Expecter) MustConnect(ctx interface{}) *Manager_MustConnect_Call {
	return &Manager_MustConnect_Call{Call: _e.mock.On("MustConnect", ctx)}
}

func (_c *Manager_MustConnect_Call) Run(run func(ctx context.Context)) *Manager_MustConnect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *Manager_MustConnect_Call) Return(_a0 inmemory.Manager) *Manager_MustConnect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_MustConnect_Call) RunAndReturn(run func(context.Context) inmemory.Manager) *Manager_MustConnect_Call {
	_c.Call.Return(run)
	return _c
}

// Ping provides a mock function with given fields:
func (_m *Manager) Ping() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Ping")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_Ping_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Ping'
type Manager_Ping_Call struct {
	*mock.Call
}

// Ping is a helper method to define mock.On call
func (_e *Manager_Expecter) Ping() *Manager_Ping_Call {
	return &Manager_Ping_Call{Call: _e.mock.On("Ping")}
}

func (_c *Manager_Ping_Call) Run(run func()) *Manager_Ping_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *Manager_Ping_Call) Return(_a0 error) *Manager_Ping_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_Ping_Call) RunAndReturn(run func() error) *Manager_Ping_Call {
	_c.Call.Return(run)
	return _c
}

// Set provides a mock function with given fields: ctx, key, value
func (_m *Manager) Set(ctx context.Context, key string, value interface{}) error {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for Set")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_Set_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Set'
type Manager_Set_Call struct {
	*mock.Call
}

// Set is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
func (_e *Manager_Expecter) Set(ctx interface{}, key interface{}, value interface{}) *Manager_Set_Call {
	return &Manager_Set_Call{Call: _e.mock.On("Set", ctx, key, value)}
}

func (_c *Manager_Set_Call) Run(run func(ctx context.Context, key string, value interface{})) *Manager_Set_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *Manager_Set_Call) Return(_a0 error) *Manager_Set_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_Set_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *Manager_Set_Call {
	_c.Call.Return(run)
	return _c
}

// SetString provides a mock function with given fields: ctx, key, value, expire
func (_m *Manager) SetString(ctx context.Context, key string, value string, expire time.Duration) error {
	ret := _m.Called(ctx, key, value, expire)

	if len(ret) == 0 {
		panic("no return value specified for SetString")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expire)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_SetString_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetString'
type Manager_SetString_Call struct {
	*mock.Call
}

// SetString is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value string
//   - expire time.Duration
func (_e *Manager_Expecter) SetString(ctx interface{}, key interface{}, value interface{}, expire interface{}) *Manager_SetString_Call {
	return &Manager_SetString_Call{Call: _e.mock.On("SetString", ctx, key, value, expire)}
}

func (_c *Manager_SetString_Call) Run(run func(ctx context.Context, key string, value string, expire time.Duration)) *Manager_SetString_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(time.Duration))
	})
	return _c
}

func (_c *Manager_SetString_Call) Return(_a0 error) *Manager_SetString_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_SetString_Call) RunAndReturn(run func(context.Context, string, string, time.Duration) error) *Manager_SetString_Call {
	_c.Call.Return(run)
	return _c
}

// SetWhenNotExist provides a mock function with given fields: ctx, key, value
func (_m *Manager) SetWhenNotExist(ctx context.Context, key string, value interface{}) error {
	ret := _m.Called(ctx, key, value)

	if len(ret) == 0 {
		panic("no return value specified for SetWhenNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}) error); ok {
		r0 = rf(ctx, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_SetWhenNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWhenNotExist'
type Manager_SetWhenNotExist_Call struct {
	*mock.Call
}

// SetWhenNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
func (_e *Manager_Expecter) SetWhenNotExist(ctx interface{}, key interface{}, value interface{}) *Manager_SetWhenNotExist_Call {
	return &Manager_SetWhenNotExist_Call{Call: _e.mock.On("SetWhenNotExist", ctx, key, value)}
}

func (_c *Manager_SetWhenNotExist_Call) Run(run func(ctx context.Context, key string, value interface{})) *Manager_SetWhenNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}))
	})
	return _c
}

func (_c *Manager_SetWhenNotExist_Call) Return(_a0 error) *Manager_SetWhenNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_SetWhenNotExist_Call) RunAndReturn(run func(context.Context, string, interface{}) error) *Manager_SetWhenNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// SetWithExpire provides a mock function with given fields: ctx, key, value, expire
func (_m *Manager) SetWithExpire(ctx context.Context, key string, value interface{}, expire time.Duration) error {
	ret := _m.Called(ctx, key, value, expire)

	if len(ret) == 0 {
		panic("no return value specified for SetWithExpire")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expire)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_SetWithExpire_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWithExpire'
type Manager_SetWithExpire_Call struct {
	*mock.Call
}

// SetWithExpire is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expire time.Duration
func (_e *Manager_Expecter) SetWithExpire(ctx interface{}, key interface{}, value interface{}, expire interface{}) *Manager_SetWithExpire_Call {
	return &Manager_SetWithExpire_Call{Call: _e.mock.On("SetWithExpire", ctx, key, value, expire)}
}

func (_c *Manager_SetWithExpire_Call) Run(run func(ctx context.Context, key string, value interface{}, expire time.Duration)) *Manager_SetWithExpire_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *Manager_SetWithExpire_Call) Return(_a0 error) *Manager_SetWithExpire_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_SetWithExpire_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) error) *Manager_SetWithExpire_Call {
	_c.Call.Return(run)
	return _c
}

// SetWithExpireWhenNotExist provides a mock function with given fields: ctx, key, value, expire
func (_m *Manager) SetWithExpireWhenNotExist(ctx context.Context, key string, value interface{}, expire time.Duration) error {
	ret := _m.Called(ctx, key, value, expire)

	if len(ret) == 0 {
		panic("no return value specified for SetWithExpireWhenNotExist")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, interface{}, time.Duration) error); ok {
		r0 = rf(ctx, key, value, expire)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Manager_SetWithExpireWhenNotExist_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetWithExpireWhenNotExist'
type Manager_SetWithExpireWhenNotExist_Call struct {
	*mock.Call
}

// SetWithExpireWhenNotExist is a helper method to define mock.On call
//   - ctx context.Context
//   - key string
//   - value interface{}
//   - expire time.Duration
func (_e *Manager_Expecter) SetWithExpireWhenNotExist(ctx interface{}, key interface{}, value interface{}, expire interface{}) *Manager_SetWithExpireWhenNotExist_Call {
	return &Manager_SetWithExpireWhenNotExist_Call{Call: _e.mock.On("SetWithExpireWhenNotExist", ctx, key, value, expire)}
}

func (_c *Manager_SetWithExpireWhenNotExist_Call) Run(run func(ctx context.Context, key string, value interface{}, expire time.Duration)) *Manager_SetWithExpireWhenNotExist_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(interface{}), args[3].(time.Duration))
	})
	return _c
}

func (_c *Manager_SetWithExpireWhenNotExist_Call) Return(_a0 error) *Manager_SetWithExpireWhenNotExist_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Manager_SetWithExpireWhenNotExist_Call) RunAndReturn(run func(context.Context, string, interface{}, time.Duration) error) *Manager_SetWithExpireWhenNotExist_Call {
	_c.Call.Return(run)
	return _c
}

// NewManager creates a new instance of Manager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *Manager {
	mock := &Manager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
